<!-- Template for PROJECT REPORT of CapstoneDesign 2025-2H, initially written by khyoo -->
<!-- 본 파일은 2025년도 컴공 졸업프로젝트의 <1차보고서> 작성을 위한 기본 양식입니다. -->
<!-- 아래에 "*"..."*" 표시는 italic체로 출력하기 위해서 사용한 것입니다. -->
<!-- "내용"에 해당하는 부분을 지우고, 여러분 과제의 내용을 작성해 주세요. -->

# Team-Info
| (1) 과제명 |  AI NPC 입체적 역할 부여를 통해 단조로운 대화패턴을 탈피한 <변호사 VS 검사> 재판 시뮬레이션 멀티플레이 게임 |
|:---  |---  |
| (2) 팀 번호/이름 | 33-아리아리 |
| (3) 구성원 | 전유진 (2116020): 리더,*PM, 클라이언트* <br> 박시언 (2140015): 팀원,*기획, AI* <br> 유서현(2071031): 팀원,*기획, 서버* |
| (4) 지도교수 | 김영준 교수 |
| (5) 트랙  | 산학 |
| (6) 과제 키워드 | 생성형 AI를 통한 컨텐츠 자동생성, AI NPC와의 커뮤니케이션, 멀티플레이 게임, 재판 |
| (7) 과제 내용 요약 |  꽥투헬은 저승과 이승의 경계인 삼도천에서 망자를 천국 또는 지옥으로 보내기 위해 경쟁하는 2인 재판 게임이다. 스테이지는 마을(증거수집 현장)과 재판장(재판 현장)으로 나뉜다. 플레이어는 마을에서 NPC와의 대화 및 증거물 수집을 통해 단서를 얻고, 이를 토대로 재판장에서 어필할 수 있다. 게임의 핵심 기술은 AI이며, AI는 ① 매 판 자동 콘텐츠 생성을 담당하는 God, ② 플레이어와 대화하는 NPC, ③ DALL·E 기반의 증거물 이미지 생성, ④ 재판을 주관하는 판사 AI로 구성되어 있다.  <br><br> ※ 본 게임은 사회적 메시지나 진지한 법적 토론을 목표로 하지 않으며, 플레이어는 재판에서 승리하기 위해 수단과 방법을 가리지 않는 경쟁을 펼친다. 플레이어는 NPC를 회유하거나, 불리한 증거를 숨기고, 재판장을 자신의 논리로 설득하는 등 승부에 집중한 플레이 경험을 즐길 수 있도록 설계되어 있다.|
| (8) 주요 Link | 꽥투헬 깃허브 레포지토리: [https://github.com/AriAri-Project](https://github.com/AriAri-Project/QuackToHell)|

<br>

# Project-Summary

| 항목 | 내용 |
|:---|:---|
| (1) 문제 정의 | **Target Customer**<br>1. 마피아 게임이나 채팅형 어필 경쟁 게임을 선호하는 유저<br>2. 재판 게임 장르를 즐기는 유저<br>3. 플레이할 때마다 다른 상황이 펼쳐지는, 리플레이성이 높은 게임을 선호하는 유저<br>4. 단순한 규칙 속에서 예측 불가능하고 다이나믹한 상황 전개를 즐기는 유저<br><br>**Pain Points**<br>1. 기존게임: 정해진 캐릭터 & 고정된 스토리로 인한 단조로운 대화 패턴<br>2. 인디게임의 한계: 빠른 콘텐츠 소모 속도를 기획 생산력이 따라가지 못 함<br>3. 기존 게임: AI를 단순 조력자 / 적으로 배치 (역할 고정) |
| (2) 기존연구와의 비교 | **유사 게임 사례**<br>1. 고정된 캐릭터 & 스토리 → 대화 패턴이 단조로운 게임<br>  - 《역전재판》 시리즈<br>  → 사전에 제작된 고정 스토리와 캐릭터 대사에 기반해 진행되며, 반복 플레이 시 동일한 스토리라인과 대화 패턴 노출로 인해 리플레이성 한계 존재.<br>2. 빠른 콘텐츠 소비 속도를 기획 생산력이 따라가지 못하는 사례<br>  - 《스타듀밸리 (Stardew Valley)》<br>  → 개발자 1인이 모든 콘텐츠를 기획·개발했기 때문에, 업데이트 주기가 매우 길고 불규칙함.<br>3. AI 역할이 고정되어 있는 게임 사례<br>  - 《두근두근 AI 심문게임》<br>  → AI 역할이 심문 대상에 고정되어 있으며, 플레이어의 행동이나 선택에 따라 AI의 입장이나 목적이 변화하지 않음.<br><br>**기존 사례의 한계점**<br>1. 고정된 콘텐츠 구조<br>→ 기존 재판/추리 게임은 사전에 제작된 캐릭터, 스토리, 대사에 의존하여 플레이 횟수에 따라 콘텐츠 소모와 재미 감소 문제가 있음.<br>2. AI 활용의 제한성<br>→ 기존 AI 게임들은 스토리 자동생성 기능에 집중되어 있지만, 플레이어의 행동에 따른 AI 역할 변화 구조는 부재. 기존의 AI 게임은 AI 역할이 고정되어있다는 한계가 있음.<br>3. 리플레이성 한계<br>→ 기존 AI 게임들은 플레이어의 선택에 따라 NPC의 입장이나 게임 전개가 근본적으로 달라지지 않음. 인력으로 기획 리소스를 제작한 게임은, 컨텐츠 소모 속도를 기획이 따라가지 못해 리플레이를 제한한다는 단점이 있음. <br><br>**본 과제의 차별성 및 장점**<br>1. 생성형 AI 기반의 콘텐츠 생성으로 매 판마다 새로운 재판 사건, NPC 인격, 증거물이 자동 생성되어 콘텐츠 고갈 문제를 구조적으로 해결.<br>2. 플레이어의 행동과 평판 관리에 따라 NPC의 증언 내용과 게임 승패가 실시간으로 변화하는 능동적 게임 구조 구현.<br>3. 기존 AI 게임과 달리, AI가 조력자·적의 고정된 역할에 머무르지 않고, 플레이어가 원하는 방향으로 역할을 유도할 수 있는 시스템 적용.<br>4. 인디게임 개발 리소스 한계를 AI 기술로 극복하여 지속 가능한 서비스 가능성 확보. |
| (3) 제안 내용 | 1. 기존게임: 정해진 캐릭터 & 고정된 스토리로 인한 단조로운 대화 패턴<br>→ 우리게임: 생성형 ai로 매 판 NPC의 인격 & 스토리를 자동 생성해 정적인 캐릭터성 극복 & 다채로운 대화패턴 상황을 연출함. 매 판 다른 NPC성격과 상황을 통해 예측 불가능한 레퍼토리와 몰입감있는 플레이를 제공함.<br><br>2. 인디게임의 한계: 빠른 콘텐츠 소모 속도를 기획 생산력이 따라가지 못 함<br>→ 우리게임: 생성형 ai 사용해 매 판마다 새로운 재판 사건과 단서, NPC 인격을 자동 생성함으로써 기획 리소스 소모 없이 콘텐츠 고갈 문제를 해결함.<br><br>3. 기존 게임: AI를 단순 조력자 / 적으로 배치 (역할 고정)<br>→ 우리게임: 플레이어는 게임 내에서 NPC와의 대화, 행동, 평판 관리를 통해 AI NPC의 역할을 능동적으로 변화시킬 수 있음. 즉, AI의 역할이 고정되어 있는 것이 아니라, 플레이어가 원하는 방향으로 AI가 행동하도록 유도해야 함. 최종적으로, 마을에서의 플레이어의 행동이 재판장에서 NPC의 증언으로 이어지며, 그 증언이 플레이어에게 유리하게 작용해 게임의 승패에 영향을 미치도록 설계함. |
| (4) 기대효과 및 의의 | **사회적 영향력**<br>1. 산업 혁신 선도: 생성형 AI를 활용한 멀티플레이 재판 추리 게임으로, AI 기반 스토리텔링과 경쟁 구조의 결합이라는 새로운 게임 장르의 가능성 제시.<br>2. 사회적 대화 촉진 가능성: 게임의 법적 설정과 플레이 경험이, 현실 사회의 법적·윤리적 쟁점에 대한 가벼운 토론의 출발점이 될 수 있음.<br>3. AI 판사 논의의 소재 제공: AI 판사 NPC의 도입이 AI의 공정성, 책임성에 대한 논의의 소재로 활용될 가능성.<br><br>**콘텐츠 산업 기여도**<br>1. 스토리텔링 방식의 확장 가능성: 매 판 자동 생성되는 캐릭터·사건 구조가, 게임 산업 내 AI 기반 동적 서사 제공 모델로 확장될 수 있음.<br>2. AI 기술의 게임 개발 적용 가능성 제시: AI 도구를 통해 콘텐츠 제작 효율을 높이는 AI 기반 게임 개발의 사례로 활용될 수 있음.<br>3. 교육·토론 도구로의 확장 가능성: 플레이어가 증거를 숨기거나 NPC를 조종하는 시스템 구조가, 향후 법적·윤리적 딜레마 학습 도구로 전환될 여지도 있음. |
| (5) 주요 기능 리스트 | 게임의 핵심 기술은 생성형 AI이며, OpenAI API를 사용한다. AI는 다음 네 가지 구성 요소로 이루어져 있다.<br><br>1. God 시스템 (콘텐츠 자동 생성 담당)<br>- 매 판마다 피고인과 NPC들의 배경 스토리, 성격, 가치관, 말투, 특성 등 플레이에 필요한 설정을 자동 생성한다.<br>- OpenAI API를 활용해 NPC별 프롬프트를 생성하고, 결과를 JSON 데이터로 저장하여 게임 내 스토리 정보로 활용한다.<br>- 생성된 JSON 데이터에는 NPC의 이름, 성격, 전생의 주요 사건 등이 포함되며, 게임 내 대화 컨텍스트 유지에 활용된다.<br><br>2. NPC Component 모듈 (실시간 대화 상호작용)<br>- 플레이어와 NPC 간 상호작용을 담당하며, 플레이어의 질문을 OpenAI에 전달하고, 생성된 답변을 받아 게임 내에서 NPC의 발화로 표현한다.<br>- NPC 간 자체 대화 (N2N) 및 NPC의 혼잣말 기능을 포함한다.<br>- 대화 유형(ConversationType)에 따라 상호작용 방식을 구분하여, 자연스럽고 일관된 캐릭터성을 유지한다. 대화 유형은 Player-NPC, NPC-NPC, NPC혼잣말로 구성되어있다.<br>- 플레이어와 NPC 간의 대화 기록을 지속적으로 저장·관리하여, 이전 맥락과 연결되는 자연스러운 대화 흐름을 제공한다.<br><br>3. DALL·E 기반 증거물 이미지 생성<br>- 매 판 새로운 재판 사건에 필요한 증거물 이미지를 자동 생성하여, 시각적 콘텐츠 제공 및 몰입도를 높인다.<br><br>4. 판사 AI<br>- 재판장에서의 진행을 담당하며, AI 판사 NPC로서 플레이어 간 논리 대결을 판정한다.<br>- 판례를 학습하여 파인튜닝된 모델로서 재판을 수행한다. <br><br> *네 가지 AI 구성 요소는 독립적인 기능을 수행하면서도 상호 연동되어, 플레이어의 선택과 행동에 따라 매 판마다 새로운 세계관과 대화 흐름, 증거 구성, 재판 결과를 동적으로 생성한다.*|


<br>

# Project-Design & Implementation
| 항목 | 내용 |
|:---  |---  |
| (1) 요구사항 정의 |(1) God 시스템<br>• 유스케이스:<br>  - 게임 시작 전, 피고인을 포함한 NPC들의 개별적인 성격, 배경 스토리, 주요 사건 정보, 그리고 증거물 아이템과 관련된 설정을 자동 생성한다.<br>  - 생성된 데이터는 JSON 파일로 저장되어 각 NPC들의 대화를 OpenAI를 통해 생성할 시 참조할 수 있도록 한다.<br>• 세부 기능 요구사항:<br>  - 랜덤성 및 가이드라인을 기반으로 NPC들의 성격과 배경을 자동 생성할 수 있어야 한다.<br>  - 생성된 정보는 NPC의 대화 및 반응에 영향을 미쳐야 한다.<br>  - NPC들이 특정 행동(거짓말, 회피 등)을 할 확률을 성격에 따라 조절할 수 있도록 요구사항에 맞추어 자세히 설정해야 한다.<br><br>(2) NPCComponent (대화 AI 모듈)<br>• 유스케이스:<br>  - 플레이어가 NPC에게 질문을 하면, NPC가 OpenAI를 통해 콜백을 진행하고 해당 질문과 관련된 답변을 생성해 받아온다.<br>  - 이때 NPC의 답변은 해당 NPC 본인의 기억, 성격, 사건 정보가 담긴 JSON에 따라 맞추어 조정된다.<br>  - 또한, NPC는 무조건 옳은 말만 하는 것이 아니라 거짓말을 하거나 회피하는 등 플레이어에게 다양한 반응을 보일 수 있다.<br>  - NPC는 플레이어와 나눈 대화 기록을 바탕으로 다른 NPC와 대화를 하거나, 혼잣말을 출력할 수도 있다.<br>• 세부 기능 요구사항:<br>  - 대화 데이터는 OpenAI API를 활용하여 실시간으로 생성한다.<br>  - NPC별 본인의 기억 데이터를 참조하여 개개인의 일관된 응답을 유지해야 한다.<br>  - 특정 이벤트(증거 제시 등) 이후 NPC의 태도 변화가 대사에 반영되어야 한다.<br><br>(3) 재판 시스템<br>• 유스케이스:<br>  - 재판은 모두진술, 증거조사, 피고인 심문, 배심원 발언, 최종판결 순으로 이루어진다.<br>  - 플레이어가 심문을 통해 얻은 정보를 바탕으로 NPC의 진술에 포함된 모순을 찾아낸다.<br>  - 증거를 제시하면 NPC의 반응에 실시간으로 반영되어 변화하고, 이에 따라 재판의 흐름이 달라진다.<br>  - 최종적으로 판사 AI가 내린 판결이 피고의 운명과 게임의 승패를 결정한다.<br>• 세부 기능 요구사항:<br>  - 증거 제시에 따라 배심원 NPC들의 의견이 달라질 수 있어야 한다.<br>  - 최종 판결 결과가 저장되며, 이후 게임에 영향을 줄 수 있어야 한다.<br><br>1.2 설계 모델 (클래스 및 모듈 명세서)<br>(1) 주요 클래스 다이어그램<br>• GodCall: NPC의 초기 설정을 담당하는 모듈.<br>• GodFunction: 랜덤 데이터 생성 및 NPC 설정 저장.<br>• NPCComponent: AI 기반 대화를 처리하는 NPC 모듈 (Resident, Jury, Defendant의 부모 클래스).<br>• ResidentComponent, JuryComponent, DefendantComponent: 각각 마을 주민, 배심원, 피고인을 담당하며 NPCComponent를 상속받음.<br>• TrialStatement: 재판 진행을 관리하는 클래스. |
| (2) 전체 시스템 구성 | ![전체시스템구성](https://github.com/user-attachments/assets/8b32f755-93de-48e9-8d22-9ef35257b651) *<br>1. 사용자<br>-Windows Desktop 환경에서 게임을 실행<br>-키보드와 마우스를 이용하여 캐릭터를 조작하고 게임 내 다양한 입력을 수행<br>2. Unreal Client<br>-사용자와 직접 연결된 클라이언트 환경<br>-캐릭터/컨트롤러 모듈을 통해 입력을 처리하고, 캐릭터의 시각적 표현 및 동작을 담당<br>-UI 매니저 모듈을 통해 게임 씬에 필요한 UI를 생성하고 일관되게 제어<br>-사용자의 입력과 상태 변화는 서버로 전달되며, 게임 상황에 따라 일부 처리는 클라이언트 측에서 독립적으로 수행<br>3. Unreal Listen Server<br>-멀티플레이 환경에서 호스트 역할을 수행하는 서버<br>-SteamSubsystem을 이용한 WAN 기반 로비 시스템을 통해 온라인 세션을 생성하고, 외부 플레이어의 참여를 지원<br>-RPC 함수 기반의 서버-클라이언트 동기화 시스템을 통해 플레이어 상태, 대화 요청, 행동 등을 실시간 동기화<br>-게임 로직 처리 시스템에서 NPC 스폰, 재판 진행, 이벤트 트리거 등 핵심 게임 진행 로직을 제어<br>4. OpenAI 시스템<br>-서버에서 OpenAI API를 호출하여 게임 내 세계관 및 AI 기능을 지원<br>-세계관 생성 시스템에서는 NPC의 배경, 성격, 이름 등의 데이터를 자동 생성하여 JSON 형태로 서버에 전달<br>-NPCComponent 및 판사 AI 시스템에서는 플레이어와의 대화, 혼잣말, NPC 간 대화, 재판 발언 등의 AI 응답을 생성<br>-DALL·E 기반 이미지 생성 시스템을 통해 증거물 이미지를 생성하고, 게임 내 UI에서 활용될 수 있도록 저장*|
| (3) 주요엔진 및 기능 설계 | ~~꽥투헬 클라이언트는 Unreal Engine의 핵심 클래스를 확장한 계층적 구조를 기반으로 구현되며, 캐릭터와 컨트롤러가 명확히 분리되어 각 역할에 맞게 설계된다.<br>기본 캐릭터인 QCharacter를 중심으로 플레이어와 NPC가 각각 QPlayer, QNPC로 구분되며, 세부적으로는 QLawyer, QProsecutor, QDefendant, QDynamicNPC 등이 존재하고, NPC의 경우 정적과 동적 구분에 따라 QJury, QResident 등이 추가 상속된다.<br>이에 맞춰 플레이어와 NPC를 제어하는 컨트롤러 역시 QPlayerController와 QNPCController로 구분되고, 동적 NPC는 QDynamicController를 통해 QJuryController, QResidentController 등으로 세분화된다.<br>UI 측면에서는 씬별 관리자인 QVillageUIManager와 QCourtUIManager가 단일 인스턴스(Singleton) 형태로 전체 인터페이스를 통합 관리하며, 기타 UI 요소들은 해당 관리자를 통해 생성 및 제거된다.<br><br>서버 구현 측면에서는 언리얼 리슨 서버(Unreal Listen Server)를 활용하여 클라이언트와 AI 시스템 간의 안정적인 통신 채널을 구축하고 있다.<br>데디케이티드 서버가 아니기에 서버는 각 세션의 호스트의 로컬 환경에서 구동됩니다.<br>이를 통해 클라이언트는 AI(즉, God 시스템과 NPCComponent 모듈)와의 원활한 상호작용을 보장받으며, 게임 내 다양한 NPC의 배경 스토리, 성격, 말투 등 복합적인 데이터를 실시간으로 주고받을 수 있다.<br>또한, Unreal의 OnlineSubsystem을 활용하여 LAN 환경에 국한되지 않고 WAN 환경에서도 멀티플레이어 유저를 효과적으로 탐색하고, 세션을 형성할 수 있도록 구현하였다.<br>이를 통해 전 세계의 플레이어들이 하나의 네트워크에서 안정적으로 연결되고, 원활한 게임 플레이를 경험할 수 있다.<br><br>꽥투헬의 AI 시스템은 God 시스템과 NPCComponent 모듈을 중심으로 설계되어 있다.<br>God 시스템은 AI의 핵심 엔진 역할을 하며, 피고인을 포함한 NPC들의 개별적인 배경 스토리, 성격 및 가치관, 말투, 특성 등을 생성하는 역할을 수행한다.<br>이 과정에서 God은 OpenAI API를 활용하여 NPC별 프롬프트를 생성하고, 그 결과를 JSON 파일로 저장함으로써 NPC들의 개성을 반영한 JSON SCHEMA를 만든다.<br>더불어 NPC들의 JSON에는 이름, 성격, 전생의 주요 사건 등이 포함되며, 이러한 정보는 게임 내에서 NPC들의 대화 컨텍스트 유지에도 활용된다.<br><br>한편, NPCComponent 모듈은 개별 NPC가 플레이어와 상호작용하는 기능을 담당한다.<br>NPC가 플레이어의 질문을 받으면 해당 요청을 OpenAI에 전달하고, OpenAI가 생성한 응답을 다시 받아 서버에 보내는 역할을 한다.<br>NPCComponent는 단순히 OpenAI의 응답을 전달하는 것뿐만 아니라, NPC들끼리 대화를 주고받는 기능(N2N)과 NPC가 혼잣말을 하는 기능도 포함하고 있다.<br>이를 위해 NPCComponent는 대화 유형을 ConversationType으로 구분하여 처리하며, UI 출력 시스템과 연동하여 NPC의 발화를 자연스럽게 게임 내에서 표현할 수 있도록 설계되어 있다.<br>또한, 대화 기록을 저장하고 관리하여 NPC의 발언이 이전 맥락과 어울리도록 조정하는 역할도 수행한다.<br>NPC와 플레이어의 대화 기록은 지속적으로 저장되고 이후 NPC 간 대화 및 그들의 혼잣말에 반영하여, NPC가 더욱 자연스럽고 일관된 성격을 유지할 수 있도록 한다.<br><br>이러한 구조를 통해 꽥투헬의 AI 시스템은 각 NPC들이 개별적인 개성을 유지하면서도 플레이어와 몰입도 높은 상호작용을 할 수 있도록 돕는다.<br>God 시스템이 피고인 및 NPC의 배경 스토리, NPC의 성격 등 게임의 바탕이 되는 모든 설정들을 생성하고, NPCComponent가 이를 게임 내에서 실시간으로 반영하는 방식으로 구현되어 있어, 플레이어는 마치 하나의 작은 사회에 속한 듯한 경험을 할 수 있다.~~ <br><br> ***Client-Side**<br>**Client 기능 상세 구현 내용**<br><br>기능 개요<br><br>-Unreal Client Module은 게임 내에서 다양한 역할을 수행하는 캐릭터와 사용자 인터페이스(UI)를 효과적으로 제어하기 위한 모듈이다.<br>-이 모듈은 언리얼 엔진의 핵심 클래스를 기반으로 계층적 구조로 설계되었으며, 캐릭터와 컨트롤러 간 책임 분리를 통해 각 기능이 독립적으로 수행되도록 구성되었다.<br>-UI 시스템은 각 씬 단위로 Singleton 기반의 UI 매니저를 채택하여, 일관된 사용자 경험과 효율적인 UI 제어를 가능하게 한다.<br><br>주요 기능 흐름<br><br>-캐릭터 구조는 캐릭터 클래스(QCharacter 계열)와 컨트롤러 클래스(QController 계열)로 나뉘며, 외형적 표현과 논리 제어를 분리하여 처리한다.<br>-QPlayerController는 플레이어의 입력을 감지하고, QPlayer에게 명령을 전달하며, 입력에 따라 캐릭터의 애니메이션 및 시야를 제어한다.<br>-NPC는 정적인 QDefendantNPC와 동적인 QDynamicNPC로 구분되며, QDynamicNPC는 Behavior Tree를 기반으로 자동 이동한다.<br>-NPC는 기능에 따라 QJuryNPC, QResidentNPC 등으로 분기되어 각기 다른 동작을 수행한다.<br><br>기능 세부 구조<br><br>캐릭터 클래스 구조<br>-QCharacter: 기본 캐릭터 클래스<br>-QPlayer: 플레이어 캐릭터 → QProsecutor, QLawyer로 역할 분화<br>-QNPC: NPC 캐릭터 → QDefendantNPC (정적), QDynamicNPC (이동 가능)<br>-QDynamicNPC → QJuryNPC, QResidentNPC로 분기<br>컨트롤러 클래스 구조<br>-QPlayerController: 플레이어 입력 처리<br>-QNPCController: NPC 제어<br>-QDynamicController → QJuryController, QResidentController로 세분화<br>UI 시스템<br>-Singleton 기반 VillageUIManager 사용<br>-TurnOnUI(EVillageUIType) 함수로 UI 초기화<br>-UI 생성은 최초 1회만 수행되고 이후 모든 UI 제어는 매니저를 통해 수행됨<br><br>실험 전체 내용 및 부분 기술<br><br>-캐릭터와 컨트롤러 간의 역할 분리를 바탕으로 상호작용 실험을 수행<br>-입력 로직은 컨트롤러에서, 시각 표현은 캐릭터에서 담당하도록 구조 분리<br>-NPC의 AI 제어는 각 컨트롤러 클래스에서 처리되며, Behavior Tree 기반의 자연스러운 이동과 상호작용을 구현<br>-UI 매니저는 씬별로 UI를 중앙 관리하며, 위젯 중복 생성을 방지하고 메모리 사용 효율을 높임<br>실험 결과<br>-클라이언트 모듈의 계층 구조는 유지보수성과 확장성을 높이는 데 효과적이었으며, 각 컴포넌트의 책임이 명확히 분리됨<br>-NPC 동작은 유형별로 세분화되어 플레이어 상호작용의 다양성을 증가시킴<br>-UI 시스템은 Singleton 기반 구조를 통해 리소스 낭비를 방지하고, UI 생명 주기를 일관되게 유지함<br>-전체적으로 모듈화 설계를 바탕으로 향후 캐릭터 및 인터페이스 확장에 유연하게 대응 가능함<br><br>**Server-Side**<br>**1. SteamSubSystem을 이용한 WAN 기반 로비 시스템**<br><br>기능 개요<br><br>-본 기능은 LAN 환경을 넘어 WAN(전 세계 네트워크)에서도 플레이어가 세션을 탐색하고 참여할 수 있도록 구현된 로비 시스템이다.<br>-Unreal Engine의 SteamSubsystem을 활용하여 WAN 기반의 세션 생성, 탐색, 참여가 가능하며, PlayFab과 연동하여 유저 정보 및 매치 기록도 관리된다.<br>-멀티플레이 환경에서 플레이어 매칭, 호스트 전환, 세션 유지를 담당한다.<br><br>주요 기능 흐름<br><br>-게임 시작 시 로그인 → 서버 세션 생성 or 탐색 → 세션 참가 or 호스트 전환<br>1. 로그인 및 인증 처리 (Steam 계정 기반)<br>2. IOnlineSession 인터페이스 기반의 세션 생성 (CreateSession)<br>3. 서버 리스트 검색 및 결과 필터링 (FindSessions)<br>4. 세션 참가 시 JoinSession을 통해 연결 요청<br>5. SeamlessTravel 기반의 맵 전환 및 상태 유지 처리<br><br>기능 세부 구조<br><br>USteamSessionManager<br>-InitSteamInterface(): SteamSubsystem 초기화 및 온라인 세션 핸들 바인딩<br>-CreateSession(): 로비 호스트용 세션 생성 처리<br>-FindSessions(): 클라이언트 측 세션 탐색 기능 (ping, 유저 수 필터 포함)<br>-JoinSession(): 탐색된 세션에 참가 시도<br>-OnSessionJoined(): 참가 성공 시 SeamlessTravel 호출 및 연결 처리<br>플레이어 인증 및 로딩 UI 연계<br>-로비 UI에서 세션 탐색, 호스트, 참가 버튼과 연동<br><br>실험 전체 내용 및 부분 기술<br><br>전체 실험: 서버/클라이언트 간 WAN 환경에서의 세션 탐색 및 참여 테스트<br>기능별 실험:<br>-세션 검색 속도 및 정확도 측정<br>-세션 참가 후 맵 전환 일관성 확인<br>-호스트 장애 발생 시 클라이언트 에러 처리 검증<br>-SteamSubsystem 연동 시 Steam ID 기반 유저 추적 기능 확인<br><br>**2. RPC 함수에 기반한 서버 - 클라이언트 동기화 시스템**<br><br>기능 개요<br><br>-본 기능은 Unreal Engine의 Remote Procedure Call(RPC) 시스템을 기반으로 서버와 클라이언트 간 데이터를 실시간으로 동기화하는 핵심 메커니즘이다.<br>-서버 권한 데이터를 클라이언트에 반영하거나, 클라이언트 요청을 서버에서 처리하는 등의 흐름이 주요 목적이다.<br>-RepNotify, ServerRPC, ClientRPC, MulticastRPC를 체계적으로 활용한다.<br><br>주요 기능 흐름<br><br>-클라이언트에서 특정 액션 발생 → ServerRPC 요청<br>-서버에서 처리 후 → ClientRPC 또는 MulticastRPC로 전파<br>-동기화 대상 변수는 Replicated / OnRep 함수로 자동 적용<br><br>기능 세부 구조<br><br>AQPlayerController / AQPlayer / UNPCComponent<br>-ServerRPCStartConversation(): NPC 대화 시작 요청 (서버 권한)<br>-MulticastRPCDisplayBubble(): 대화 UI 전파용 멀티캐스트<br>-ClientRPCUpdateStatus(): 클라이언트 전용 상태 갱신 함수<br>변수 동기화<br>-bIsTalking, CurrentTargetNPC 등은 Replicated 지정<br>-OnRep_CurrentTargetNPC(): UI 갱신 등 추가 처리<br><br>실험 전체 내용 및 부분 기술<br><br>전체 실험: 클라이언트-서버 간 RPC 흐름이 의도대로 작동하며, 상태가 양쪽에서 일관되게 유지되는지 확인<br>기능별 실험:<br>-P2N 대화 RPC 요청 → UI 출력 및 서버 로그 일치 여부<br>-Multicast 방식 시 클라이언트 전파 지연 최소화 확인<br>-Replicated 변수가 클라이언트 진입 시 자동 동기화되는지 확인<br>-서버-클라 권한 체크 및 비정상 요청 차단 테스트<br><br>**3. 게임 로직 처리 시스템**<br><br>기능 개요<br><br>-본 기능은 재판 중심 스토리 진행, NPC 상호작용, 플레이어 진행 상태 등 게임 전반의 핵심 로직을 처리한다.<br>-NPC, 증거물, 맵 전환, 플레이어 행동 제한 등의 다양한 요소가 GameMode, GameState, PlayerState 등을 통해 통합 관리된다.<br>-세션 기반으로 상태를 유지하며, 서버 주도형 흐름을 구성<br><br>주요 기능 흐름<br><br>1. GameInstance에서 맵 로딩 및 상태 초기화<br>2. GameMode → NPC 스폰 및 로직 분기<br>3. GameState → 대화 기록, 판결 상태 등 공유 데이터 유지<br>4. PlayerState → 개인 기록 (선택지, 진술 등) 저장<br><br>기능 세부 구조<br><br>AQVillageGameMode<br>-BeginPlay()에서 NPC 및 맵 구조 초기화<br>-CheckTrialReadyState(): 모든 플레이어가 준비되었는지 확인 후 재판 시작<br>AQVillageGameState<br>-ConversationRecord, TrialStatus 등 전체 게임 상태 변수 보유<br>-MulticastRPCUpdateServerTime(): 시간/이벤트 동기화 처리<br>AQPlayerState<br>-GetRecordWithPlayerID(): 플레이어별 발언/행동 기록 조회<br>게임 흐름 제어<br>-예: 대화 완료 시 → 증거 열람 → 재판 개시 순서 로직<br><br>실험 전체 내용 및 부분 기술<br><br>전체 실험: 게임 시작부터 종료까지 모든 로직이 연동되어 자연스럽게 진행되는지 확인<br>기능별 실험:<br>-NPC 스폰 및 초기 설정 동작 확인<br>-플레이어 입장 후 상태 유지 (PlayerState 동기화)<br>-게임 중간 저장 및 다시 입장 시 상태 복원 테스트<br>-조건 미충족 시 특정 액션 제한 (예: 증거 부족 시 재판 불가 등)<br><br>**OpenAI-Side**<br>**1.God 기능 상세 구현 내용**<br><br>1. 기능 개요<br><br>• SW 구조에 나타난 모듈 중 OpenAI God의 핵심을 담당하고 있는 기능이다.<br>• God 기능은 꽥투헬 세계관 내 NPC들의 배경 스토리, 성격, 역할을 자동으로 생성하는 시스템이다.<br>• OpenAI API를 활용해, NPC 각각의 설정 데이터(JSON 파일)를 자동 생성한다.<br>• 생성된 데이터는 게임 내 NPCComponent가 참조하여, NPC의 대화 및 행동에 반영된다.<br><br>2. 주요 기능 흐름<br><br>• PromptToGod.json → PromptToDefendant.json → PromptToJury.json → PromptToResident.json 순서로 계층적 데이터 생성<br>1. PromptToGod.json<br>- 개발자가 작성한 세계관 기초 설정 파일<br>2. PromptToDefendant.json<br>- 피고인 NPC의 상세 정보 생성<br>3. PromptToJuryX.json<br>- 배심원 NPC 3명의 정보 순차 생성<br>4. PromptToResidentX.json<br>- 마을 주민 NPC 5명의 정보 순차 생성<br>• 파일 저장 경로<br>- Saved/Prompt/ 폴더에 각 NPC의 JSON 데이터 파일로 저장<br><br>3. 기능 세부 구조<br><br>• UGodFunction<br>- CallOpenAIAsync(): OpenAI API 호출 비동기 처리 및 3회 재시도 기능<br>- SavePromptToFile(): 생성된 프롬프트 데이터를 JSON 파일로 저장<br>- GenerateDefendantPrompt(): 피고인 NPC 정보 생성<br>- GenerateJuryNPC(): 배심원 NPC 순차 생성<br>- GenerateResidentNPC(): 마을 주민 NPC 순차 생성<br>- ExtractValidJson() / CleanUpJson(): OpenAI 응답에서 유효한 JSON 데이터만 추출 및 정제<br>• UGodCall<br>- 게임 시작 시 자동 호출<br>- PostInitProperties()에서 NPC 데이터 생성 시작<br>- World context를 통해 World 객체 접근 후 GodFunction 호출<br><br>4. 실험 전체 내용 및 부분 기술<br><br>• 실험 전체:<br>- 게임 초기화 시 세계관 설정부터 피고인, 배심원, 마을 주민까지 총 9명의 NPC 설정 데이터를 자동 생성.<br>- 각 JSON 데이터가 정상 저장되었는지 확인 후, 게임 내에서 NPCComponent에 로딩 → 대화/행동 테스트 진행.<br>• 기능별 실험:<br>- API 응답 검증: OpenAI 응답이 JSON 형식으로 유효하게 파싱되는지 및 에러 케이스(빈 응답, 파싱 실패 등) 처리 여부 테스트<br>- 파일 저장 검증: 생성된 NPC 설정 파일이 올바른 경로(Saved/Prompts)에 저장되고 내용 일관성 확인<br>- NPC 연결 검증: 생성된 설정 데이터를 NPCComponent가 문제없이 로드하여 대화 및 행동에 반영하는지 확인<br>- 실패 복구 테스트: 네트워크 실패 등 오류 발생 시 최대 3회 재시도 로직이 작동하는지 검증<br><br>**2. NPCComponent 상세 구현 내용**<br><br>1. 기능 개요<br><br>• SW 구조에 나타난 모듈 중 OpenAI NPC Component의 핵심을 담당하는 기능이다.<br>• UNPCComponent는 NPC Actor에 부착되어, NPC의 대화, 혼잣말, 재판 진술 등 AI 기반 발화 기능을 담당한다.<br>• NPC 간 대화(N2N), 플레이어와 NPC 대화(P2N), 혼잣말(NMonologue), 재판 모두진술(OpeningStatement) 등 다양한 상황을 처리한다.<br><br>2. 기능 세부 구조<br><br>• NPC 설정 정보 로딩 - LoadPrompt()<br>- God 기능에서 생성한 NPC의 JSON 데이터 파일을 읽고, NPCID, 이름, 역할, 성격 등의 정보를 메모리에 로드<br>• 대화 처리 기능<br>- P2N 대화 - StartConversation(): 플레이어가 NPC에게 말을 걸 때, NPC의 세계관 설정과 대화 히스토리를 바탕으로 대답 생성<br>- N2N 대화 - StartNPCToNPCDialog() → ContinueNPCToNPCDialog(): NPC 두 명이 서로 자연스럽게 대화하도록 AI에 요청하고, 최대 4턴까지 자동 대화 이어나감<br>- 혼잣말(NMonologue) - PerformNPCMonologue(): 최근 플레이어와의 대화 내용을 바탕으로, NPC 혼잣말 생성<br>- 재판 모두진술(OpeningStatement) - TrialStatement(): 피고인 NPC가 자신의 과거에 대한 진술을 AI를 통해 생성<br>• 대화 히스토리 관리<br>- 플레이어와 NPC 간 대화 기록을 P2NDialogueHistory에 저장하여, NPC의 발화에 반영<br>• 서버와 동기화<br>- NPC의 대화 결과는 서버에 전송되어 대화 기록으로 저장되며, UI에도 실시간 표시 (SendNPCResponseToServer())<br><br>3. 실험 전체 내용 및 부분 기술<br><br>• 실험 전체:<br>- 피고인/배심원/마을 주민 각기 다른 NPC를 대상으로 대화 상호작용을 테스트하여 발화 품질, 자연스러움, 몰입도를 평가.<br>- 테스트 결과는 서버 로그 및 클라이언트 UI 출력으로 검증.<br>• 기능별 실험:<br>- 대화 품질 검증: 각 상황별로 NPC 발화 내용이 설정된 세계관/성격에 맞는지 평가<br>- 히스토리 반영 검증: 대화 히스토리가 실제로 발화에 반영되는지 및 일관성 확인<br>- N2N 연속성 검증: NPC 간 대화가 최소 2턴까지 자연스럽게 이어지는지 확인<br>- 성능/로딩 검증: 대화 요청 후 응답 속도 측정 및 실패 시 재시도 로직 작동 여부 테스트<br>- 서버 동기화 검증: 대화 내용이 서버로 정상 전송되고 기록이 저장되는지 검증<br><br>**3. DALL·E 기반 증거물 이미지 생성 상세 구현 내용**<br><br>기능 개요<br><br>• 본 기능은 매 판 새로운 재판 사건에 필요한 시각적 증거물을 자동으로 생성하여, 플레이어의 몰입도와 게임의 사실감을 높이는 역할을 수행한다.<br>• OpenAI의 이미지 생성 API(DALL·E)를 활용하여 사건별 고유한 증거물(예: 사진, 문서, 피고인의 소지품 등)을 비주얼 콘텐츠로 제작한다.<br>• 생성된 이미지는 게임 내 마을에 재판 증거물로서 나타나며, 재판 내 판결 및 심문 과정에서 플레이어의 전략적 판단에 활용된다.<br><br>주요 기능 흐름<br><br>• 증거물 생성 트리거<br>- 게임의 각 판 초기화 시 UGodFunction::GenerateEvidenceItems() 함수에서 증거물 생성 루틴을 호출<br>• 증거물 생성 과정<br>1. GenerateEvidenceItemsr()<br>- 현재 재판 사건의 주제 및 맥락 데이터를 기반으로, DALL·E API용 프롬프트를 생성<br>2. CallOpenAIAsyncI()<br>- 비동기 방식으로 OpenAI 이미지 API 호출 및 오류 재시도(최대 3회)<br>3. DownloadDalleImage()<br>- 생성된 증거물 이미지를 PNG/JPG로 저장하며, Saved/Evidence/ 폴더에 증거물 ID 기반 파일명으로 저장<br>• 증거물 메타데이터 관리<br>- "ItemInformation%d.json"에 증거물 ID, 설명, 이미지 경로를 저장하여, 게임 내에서 증거물 UI와 연동<br><br>기능 세부 구조<br><br>• UGodFunction::GenerateEvidenceItems()<br>- 재판 초기화 시 호출됨. 피고인의 전생 정보를 기반으로 증거물 생성 프로세스를 시작.<br>- 내부에서 Prompt/PromptToDefendant.json 파일을 읽어 OpenAI에게 증거물 10개를 요청.<br>- OpenAI의 응답(JSON 배열)을 파싱하고, 각 증거물에 대해 증거물 이름(name), 설명(description), 이미지 프롬프트(image_prompt)를 추출. 그리고 Prompt/ItemInformationX.json 파일로 증거물 정보를 JSON으로 저장.<br>- 이미지 프롬프트를 전달해 비동기로 이미지 생성 요청(병렬 처리).<br>• UGodFunction::DownloadDalleImage()<br>- OpenAI Image API(DALL·E 3)에 HTTPS 방식 POST 요청을 보냄.<br>- 인증: Bearer Token 방식(OpenAI API Key 사용).<br>- 요청 파라미터: prompt(전달된 이미지 프롬프트 + 스타일 추가 설명) / model(dall-e-3) / size(1024x1024) / response_format(url)<br>- 이미지 URL 추출 후 직접 다운로드 성공 시 디스크에 PNG 파일로 저장(Items/ItemImageX.png)<br>• OpenAI 인터페이스<br>- OpenAI API (DALL·E 3) 호출 시 HTTPS 방식으로 POST 요청 수행<br>- 응답 파싱: Base64 인코딩된 이미지 데이터를 디코딩 후 게임 에셋으로 변환<br>- 실패 처리: HTTP 오류 및 이미지 파싱 오류 시 최대 3회 재시도 및 오류 로그 기록<br><br>실험 전체 내용 및 부분 기술<br<br>>• 실험 전체: 테스트용 사건 데이터를 설정하여 10개의 증거물 이미지 자동 생성 후, 실제 게임 내 증거 UI에 연동하여 표시 여부와 로딩 시간, 몰입도 평가를 진행<br>• 기능별 실험:<br>- 이미지 품질 검증: 생성된 이미지의 해상도(1024x1024) 및 시각적 완성도 평가<br>- 로딩 속도 검증: 게임 시작 후 증거물 이미지 표시까지 걸리는 시간 측정<br>- 오류 검증: OpenAI API 오류 상황 시뮬레이션 후 재시도 및 오류 처리 정상 작동 여부 확인<br><br>**4. 판사 AI 상세 구현 내용**<br><br>기능 개요<br><br>• 판사 AI는 재판장의 역할을 수행하는 NPC로, 변호사와 검사의 논리 대결을 평가하고 최종 판결을 내린다.<br>• AI는 플레이어들의 주장(발언 히스토리)을 수집하고, 그 타당성과 논리 구조를 분석하여 판정 결과를 도출한다.<br>• 사전에 학습된 판례 데이터셋 기반으로 파인튜닝된 모델을 사용하여 일관된 판결 기준을 제공한다.<br><br>주요 기능 흐름<br><br>• 재판 진행 플로우(UJudgeComponent)<br>1. 변호사/검사 발언 내용을 수집 및 정리<br>2. 수집된 발언 데이터를 기반으로 OpenAI(판례 기반 파인튜닝 모델)에 평가 요청<br>3. AI 응답 결과를 게임 내 판결 UI 및 판사 NPC의 발화로 출력<br>• 판결 기록 관리<br>- 재판 결과 및 논리 분석 결과를 JSON 형식으로 저장하여 추후 판례 학습 및 게임 기록에 반영<br><br>기능 세부 구조<br><br>• UJudgeComponent<br>- 실시간으로 변호사와 검사의 발언을 수집하여 발언 히스토리 배열에 저장<br>- 발언 히스토리 + 사건 정보 JSON을 조합하여 AI 평가용 프롬프트 생성 후 OpenAI API 호출<br>- 평가 결과를 판결 UI 및 판사 NPC 발화로 출력(예: “이번 사건은 증거가 충분하지 않으며, 피고인은 무죄로 판단됩니다.”)<br>- 판결 내용을 Saved 폴더에 JSON 파일로 기록<br>• AI 인터페이스<br>- OpenAI API(판례 파인튜닝 모델) 호출 시 변호사/검사 발언 기록과 사건 메타 데이터를 포함한 프롬프트 작성<br>- 비동기 REST API 호출 후 결과 파싱 및 오류 재시도(최대 3회)<br><br>실험 전체 내용 및 부분 기술<br><br>• 실험 전체: 모의 재판 진행 후 판결 일관성, 판결 속도, 판사 발화 자연스러움 등을 평가<br>• 기능별 실험:<br>- 판결 정확도 검증: 사전에 정의한 예상 판결과 실제 AI 판결 및 공정성 비교<br>- 응답 속도 검증: JudgeComponent() 내에서 OpenAI API 호출 후 판결 출력까지 걸리는 시간 측정<br>- 오류 검증: OpenAI API 실패 상황 가상 시 재시도 및 오류 메시지 표시 정상 작동 여부 검증* |
| (4) 주요 기능의 구현 | ~~God 기능 상세 구현 내용<br>1. 기능 개요<br>• God 기능은 꽥투헬 세계관 내 NPC들의 배경 스토리, 성격, 역할을 자동으로 생성하는 시스템이다.<br>• OpenAI API를 활용해, NPC 각각의 설정 데이터(JSON 파일)를 자동 생성한다.<br>• 생성된 데이터는 게임 내 NPCComponent가 참조하여, NPC의 대화 및 행동에 반영된다.<br><br>2. 주요 기능 흐름<br>• PromptToGod.json → PromptToDefendant.json → PromptToJury.json → PromptToResident.json 순서로 계층적 데이터 생성<br>1. PromptToGod.json<br>  - 개발자가 작성한 세계관 기초 설정 파일<br>2. PromptToDefendant.json<br>  - 피고인 NPC의 상세 정보 생성<br>3. PromptToJuryX.json<br>  - 배심원 NPC 3명의 정보 순차 생성<br>4. PromptToResidentX.json<br>  - 마을 주민 NPC 5명의 정보 순차 생성<br>• 파일 저장 경로<br>  - Saved/Prompt/ 폴더에 각 NPC의 JSON 데이터 파일로 저장<br><br>3. 기능 세부 구조<br>• UGodFunction<br>  - CallOpenAIAsync(): OpenAI API 호출 비동기 처리 및 3회 재시도 기능<br>  - SavePromptToFile(): 생성된 프롬프트 데이터를 JSON 파일로 저장<br>  - GenerateDefendantPrompt(): 피고인 NPC 정보 생성<br>  - GenerateJuryNPC(): 배심원 NPC 순차 생성<br>  - GenerateResidentNPC(): 마을 주민 NPC 순차 생성<br>  - ExtractValidJson() / CleanUpJson(): OpenAI 응답에서 유효한 JSON 데이터만 추출 및 정제<br>• UGodCall<br>  - 게임 시작 시 자동 호출<br>  - PostInitProperties()에서 NPC 데이터 생성 시작<br>  - World context를 통해 World 객체 접근 후 GodFunction 호출<br><br>NPCComponent 상세 구현 내용<br>1. 기능 개요<br>• UNPCComponent는 NPC Actor에 부착되어, NPC의 대화, 혼잣말, 재판 진술 등 AI 기반 발화 기능을 담당한다.<br>• NPC 간 대화(N2N), 플레이어와 NPC 대화(P2N), 혼잣말(NMonologue), 재판 모두진술(OpeningStatement) 등 다양한 상황을 처리한다.<br><br>2. 기능 세부 구조<br>• NPC 설정 정보 로딩 - LoadPrompt()<br>  - God 기능에서 생성한 NPC의 JSON 데이터 파일을 읽고, NPCID, 이름, 역할, 성격 등의 정보를 메모리에 로드<br>• 대화 처리 기능<br>  - P2N 대화 - StartConversation(): 플레이어가 NPC에게 말을 걸 때, NPC의 세계관 설정과 대화 히스토리를 바탕으로 대답 생성<br>  - N2N 대화 - StartNPCToNPCDialog() → ContinueNPCToNPCDialog(): NPC 두 명이 서로 자연스럽게 대화하도록 AI에 요청하고, 최대 4턴까지 자동 대화 이어나감<br>  - 혼잣말(NMonologue) - PerformNPCMonologue(): 최근 플레이어와의 대화 내용을 바탕으로, NPC 혼잣말 생성<br>  - 재판 모두진술(OpeningStatement) - TrialStatement(): 피고인 NPC가 자신의 과거에 대한 진술을 AI를 통해 생성<br>• 대화 히스토리 관리<br>  - 플레이어와 NPC 간 대화 기록을 P2NDialogueHistory에 저장하여, NPC의 발화에 반영<br>• 서버와 동기화<br>  - NPC의 대화 결과는 서버에 전송되어 대화 기록으로 저장되며, UI에도 실시간 표시 (SendNPCResponseToServer())~~<br><br>***God 기능 상세 구현 내용**<br><br>1. 기능 개요<br>• SW 구조에 나타난 모듈 중 OpenAI God의 핵심을 담당하고 있는 기능이다.<br>• God 기능은 꽥투헬 세계관 내 NPC들의 배경 스토리, 성격, 역할을 자동으로 생성하는 시스템이다.<br>• OpenAI API를 활용해, NPC 각각의 설정 데이터(JSON 파일)를 자동 생성한다.<br>• 생성된 데이터는 게임 내 NPCComponent가 참조하여, NPC의 대화 및 행동에 반영된다.<br><br>2. 주요 기능 흐름<br>• PromptToGod.json → PromptToDefendant.json → PromptToJury.json → PromptToResident.json 순서로 계층적 데이터 생성<br>1. PromptToGod.json<br>  - 개발자가 작성한 세계관 기초 설정 파일<br>2. PromptToDefendant.json<br>  - 피고인 NPC의 상세 정보 생성<br>3. PromptToJuryX.json<br>  - 배심원 NPC 3명의 정보 순차 생성<br>4. PromptToResidentX.json<br>  - 마을 주민 NPC 5명의 정보 순차 생성<br>• 파일 저장 경로<br>  - Saved/Prompt/ 폴더에 각 NPC의 JSON 데이터 파일로 저장<br><br>3. 기능 세부 구조<br>• UGodFunction<br>  - CallOpenAIAsync(): OpenAI API 호출 비동기 처리 및 3회 재시도 기능<br>  - SavePromptToFile(): 생성된 프롬프트 데이터를 JSON 파일로 저장<br>  - GenerateDefendantPrompt(): 피고인 NPC 정보 생성<br>  - GenerateJuryNPC(): 배심원 NPC 순차 생성<br>  - GenerateResidentNPC(): 마을 주민 NPC 순차 생성<br>  - ExtractValidJson() / CleanUpJson(): OpenAI 응답에서 유효한 JSON 데이터만 추출 및 정제<br>• UGodCall<br>  - 게임 시작 시 자동 호출<br>  - PostInitProperties()에서 NPC 데이터 생성 시작<br>  - World context를 통해 World 객체 접근 후 GodFunction 호출<br><br>4. 실험 전체 내용 및 부분 기술<br>• 실험 전체:<br>- 게임 초기화 시 세계관 설정부터 피고인, 배심원, 마을 주민까지 총 9명의 NPC 설정 데이터를 자동 생성.<br>- 각 JSON 데이터가 정상 저장되었는지 확인 후, 게임 내에서 NPCComponent에 로딩 → 대화/행동 테스트 진행.<br>• 기능별 실험:<br>- API 응답 검증: OpenAI 응답이 JSON 형식으로 유효하게 파싱되는지 및 에러 케이스(빈 응답, 파싱 실패 등) 처리 여부 테스트<br>- 파일 저장 검증: 생성된 NPC 설정 파일이 올바른 경로(Saved/Prompts)에 저장되고 내용 일관성 확인<br>- NPC 연결 검증: 생성된 설정 데이터를 NPCComponent가 문제없이 로드하여 대화 및 행동에 반영하는지 확인<br>- 실패 복구 테스트: 네트워크 실패 등 오류 발생 시 최대 3회 재시도 로직이 작동하는지 검증<br><br>**NPCComponent 상세 구현 내용**<br><br>1. 기능 개요<br>• SW 구조에 나타난 모듈 중 OpenAI NPC Component의 핵심을 담당하는 기능이다.<br>• UNPCComponent는 NPC Actor에 부착되어, NPC의 대화, 혼잣말, 재판 진술 등 AI 기반 발화 기능을 담당한다.<br>• NPC 간 대화(N2N), 플레이어와 NPC 대화(P2N), 혼잣말(NMonologue), 재판 모두진술(OpeningStatement) 등 다양한 상황을 처리한다.<br><br>2. 기능 세부 구조<br>• NPC 설정 정보 로딩 - LoadPrompt()<br>  - God 기능에서 생성한 NPC의 JSON 데이터 파일을 읽고, NPCID, 이름, 역할, 성격 등의 정보를 메모리에 로드<br>• 대화 처리 기능<br>  - P2N 대화 - StartConversation(): 플레이어가 NPC에게 말을 걸 때, NPC의 세계관 설정과 대화 히스토리를 바탕으로 대답 생성<br>  - N2N 대화 - StartNPCToNPCDialog() → ContinueNPCToNPCDialog(): NPC 두 명이 서로 자연스럽게 대화하도록 AI에 요청하고, 최대 4턴까지 자동 대화 이어나감<br>  - 혼잣말(NMonologue) - PerformNPCMonologue(): 최근 플레이어와의 대화 내용을 바탕으로, NPC 혼잣말 생성<br>  - 재판 모두진술(OpeningStatement) - TrialStatement(): 피고인 NPC가 자신의 과거에 대한 진술을 AI를 통해 생성<br>• 대화 히스토리 관리<br>  - 플레이어와 NPC 간 대화 기록을 P2NDialogueHistory에 저장하여, NPC의 발화에 반영<br>• 서버와 동기화<br>  - NPC의 대화 결과는 서버에 전송되어 대화 기록으로 저장되며, UI에도 실시간 표시<br>(SendNPCResponseToServer())<br><br>3. 실험 전체 내용 및 부분 기술<br>• 실험 전체:<br>- 피고인/배심원/마을 주민 각기 다른 NPC를 대상으로 대화 상호작용을 테스트하여 발화 품질, 자연스러움, 몰입도를 평가.<br>- 테스트 결과는 서버 로그 및 클라이언트 UI 출력으로 검증.<br>• 기능별 실험:<br>- 대화 품질 검증: 각 상황별로 NPC 발화 내용이 설정된 세계관/성격에 맞는지 평가<br>- 히스토리 반영 검증: 대화 히스토리가 실제로 발화에 반영되는지 및 일관성 확인<br>- N2N 연속성 검증: NPC 간 대화가 최소 2턴까지 자연스럽게 이어지는지 확인<br>- 성능/로딩 검증: 대화 요청 후 응답 속도 측정 및 실패 시 재시도 로직 작동 여부 테스트<br>- 서버 동기화 검증: 대화 내용이 서버로 정상 전송되고 기록이 저장되는지 검증<br><br>**DALL·E 기반 증거물 이미지 생성 상세 구현 내용**<br>기능 개요<br>• 본 기능은 매 판 새로운 재판 사건에 필요한 시각적 증거물을 자동으로 생성하여, 플레이어의 몰입도와 게임의 사실감을 높이는 역할을 수행한다.<br>• OpenAI의 이미지 생성 API(DALL·E)를 활용하여 사건별 고유한 증거물(예: 사진, 문서, 피고인의 소지품 등)을 비주얼 콘텐츠로 제작한다.<br>• 생성된 이미지는 게임 내 마을에 재판 증거물로서 나타나며, 재판 내 판결 및 심문 과정에서 플레이어의 전략적 판단에 활용된다.<br>주요 기능 흐름<br>• 증거물 생성 트리거<br>  - 게임의 각 판 초기화 시 UGodFunction::GenerateEvidenceItems() 함수에서 증거물 생성 루틴을 호출<br>• 증거물 생성 과정<br>  1. GenerateEvidenceItemsr()<br>   - 현재 재판 사건의 주제 및 맥락 데이터를 기반으로, DALL·E API용 프롬프트를 생성<br>  2. CallOpenAIAsyncI()<br>   - 비동기 방식으로 OpenAI 이미지 API 호출 및 오류 재시도(최대 3회)<br>  3. DownloadDalleImage()<br>   - 생성된 증거물 이미지를 PNG/JPG로 저장하며, Saved/Evidence/ 폴더에 증거물 ID 기반 파일명으로 저장<br>• 증거물 메타데이터 관리<br>  - "ItemInformation%d.json"에 증거물 ID, 설명, 이미지 경로를 저장하여, 게임 내에서 증거물 UI와 연동<br>기능 세부 구조<br>• UGodFunction::GenerateEvidenceItems()<br>  - 재판 초기화 시 호출됨. 피고인의 전생 정보를 기반으로 증거물 생성 프로세스를 시작.<br>  - 내부에서 Prompt/PromptToDefendant.json 파일을 읽어 OpenAI에게 증거물 10개를 요청.<br>  - OpenAI의 응답(JSON 배열)을 파싱하고, 각 증거물에 대해 증거물 이름(name), 설명(description), 이미지 프롬프트(image_prompt)를 추출. 그리고 Prompt/ItemInformationX.json 파일로 증거물 정보를 JSON으로 저장.<br>  - 이미지 프롬프트를 전달해 비동기로 이미지 생성 요청(병렬 처리).<br>• UGodFunction::DownloadDalleImage()<br>  - OpenAI Image API(DALL·E 3)에 HTTPS 방식 POST 요청을 보냄.<br>  - 인증: Bearer Token 방식(OpenAI API Key 사용).<br>  - 요청 파라미터: prompt(전달된 이미지 프롬프트 + 스타일 추가 설명) / model(dall-e-3) / size(1024x1024) / response_format(url)<br>  - 이미지 URL 추출 후 직접 다운로드 성공 시 디스크에 PNG 파일로 저장(Items/ItemImageX.png)<br>• OpenAI 인터페이스<br>  - OpenAI API (DALL·E 3) 호출 시 HTTPS 방식으로 POST 요청 수행<br>  - 응답 파싱: Base64 인코딩된 이미지 데이터를 디코딩 후 게임 에셋으로 변환<br>  - 실패 처리: HTTP 오류 및 이미지 파싱 오류 시 최대 3회 재시도 및 오류 로그 기록<br>실험 전체 내용 및 부분 기술<br>• 실험 전체: 테스트용 사건 데이터를 설정하여 10개의 증거물 이미지 자동 생성 후, 실제 게임 내 증거 UI에 연동하여 표시 여부와 로딩 시간, 몰입도 평가를 진행<br>• 기능별 실험:<br>  - 이미지 품질 검증: 생성된 이미지의 해상도(1024x1024) 및 시각적 완성도 평가<br>  - 로딩 속도 검증: 게임 시작 후 증거물 이미지 표시까지 걸리는 시간 측정<br>  - 오류 검증: OpenAI API 오류 상황 시뮬레이션 후 재시도 및 오류 처리 정상 작동 여부 확인<br><br>**판사 AI 상세 구현 내용**<br>기능 개요<br>• 판사 AI는 재판장의 역할을 수행하는 NPC로, 변호사와 검사의 논리 대결을 평가하고 최종 판결을 내린다.<br>• AI는 플레이어들의 주장(발언 히스토리)을 수집하고, 그 타당성과 논리 구조를 분석하여 판정 결과를 도출한다.<br>• 사전에 학습된 판례 데이터셋 기반으로 파인튜닝된 모델을 사용하여 일관된 판결 기준을 제공한다.<br><br>주요 기능 흐름<br>• 재판 진행 플로우(UJudgeComponent)<br>  1. 변호사/검사 발언 내용을 수집 및 정리<br>  2. 수집된 발언 데이터를 기반으로 OpenAI(판례 기반 파인튜닝 모델)에 평가 요청<br>  3. AI 응답 결과를 게임 내 판결 UI 및 판사 NPC의 발화로 출력<br>• 판결 기록 관리<br>  - 재판 결과 및 논리 분석 결과를 JSON 형식으로 저장하여 추후 판례 학습 및 게임 기록에 반영<br><br>기능 세부 구조<br>• UJudgeComponent<br>  - 실시간으로 변호사와 검사의 발언을 수집하여 발언 히스토리 배열에 저장<br>  - 발언 히스토리 + 사건 정보 JSON을 조합하여 AI 평가용 프롬프트 생성 후 OpenAI API 호출<br>  - 평가 결과를 판결 UI 및 판사 NPC 발화로 출력(예: “이번 사건은 증거가 충분하지 않으며, 피고인은 무죄로 판단됩니다.”)<br>  - 판결 내용을 Saved 폴더에 JSON 파일로 기록<br>• AI 인터페이스<br>  - OpenAI API(판례 파인튜닝 모델) 호출 시 변호사/검사 발언 기록과 사건 메타 데이터를 포함한 프롬프트 작성<br>  - 비동기 REST API 호출 후 결과 파싱 및 오류 재시도(최대 3회)<br><br>실험 전체 내용 및 부분 기술<br>• 실험 전체: 모의 재판 진행 후 판결 일관성, 판결 속도, 판사 발화 자연스러움 등을 평가<br>• 기능별 실험:<br>  - 판결 정확도 검증: 사전에 정의한 예상 판결과 실제 AI 판결 및 공정성 비교<br>  - 응답 속도 검증: JudgeComponent() 내에서 OpenAI API 호출 후 판결 출력까지 걸리는 시간 측정<br>  - 오류 검증: OpenAI API 실패 상황 가상 시 재시도 및 오류 메시지 표시 정상 작동 여부 검증* |
| (5) 기타 |--|<br><br><br>
